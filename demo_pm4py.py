# -*- coding: utf-8 -*-
"""Demo pm4py.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15VH-OVUySOm4iWOXN10AwkWm2l7CAGhX

**Autor Original:** Victor Gálvez Yanjarí (vagalvez@uc.cl)  
**Adaptado para Google Colab por:** Ignacio Velásquez Lagos (iavelasquez@uc.cl)

### Demo PM4Py

0. [Archivos Log de Eventos](#eventlogs)
1. [Instalación](#installation)
    * 1.1. [Anaconda](#anaconda)
    * 1.2. [Graphviz](#graphviz)
    * 1.3. [PM4Py](#pm4py)


2. [Datos](#datos)
    * 2.1. [Importar .xes](#xes)
    * 2.2. [Importar .csv](#csv)
    * 2.3. [De .csv a event log](#csvtoeventlog)
    * 2.4. [De event log a dataframe de pandas](#eventlogtodf)


3. [Exploración de datos](#exploracion)
    * 3.1. [Número de casos](#ncasos)
    * 3.2. [Frecuencia de actividades](#freqactividades)
    * 3.3. [Frecuencia de ejecutores](#freqejecutores)
    * 3.4. [Throughput time](#time)
    * 3.5. [Distribución de case duration](#distcaseduration)
    * 3.6. [Distribución de eventos en el tiempo](#disteventosentiempo)
    * 3.7. [Variantes](#variantes)


4. [Descubrimiento de proceso](#discovery)
    * 4.1. [Algoritmo alfa](#alfa)
    * 4.2. [Directly follows graph](#dfg)


5. [Filtros](#filtros)
    * 5.1. [Filtrar por start activity](#filtro1)
    * 5.2. [Filtrar por end activity](#filtro2)
    * 5.3. [Filtrar trazas que contienen una actividad](#filtro3)
    * 5.4. [Filtrar trazas que no contienen una actividad](#filtro4)
    * 5.5. [Eliminar todos los eventos de una actividad](#filtro5)
    * 5.6. [Filtrar por duración de caso](#filtro6)
    * 5.7. [Filtrar trazas contenidas en un período de tiempo](#filtro7)
    * 5.8. [Filtrar casos por variante](#filtro8)

***Basado en documentación de librería PM4Py (https://pm4py.fit.fraunhofer.de/documentation)***

# 1. Archivos Log de Eventos <a class="anchor" id="eventlogs"></a>

Para correr este notebook se utilizan dos archivos correspondientes a un mismo log de eventos de Reparación de Teléfonos:
* Log de eventos en formato XES: https://www.dropbox.com/s/lvmucrpvssst9ir/reparacion_telefonos.xes?dl=1
* Log de eventos en formato CSV: https://www.dropbox.com/s/5etcpkq6dh7l88o/reparacion_telefonos.csv?dl=1

Al correr el notebook de **manera local**, estos archivos deben ser descargados y ubicados en la misma carpeta del notebook. Sin embargo, si nos encontramos trabajando en **Google Colab**, la siguiente celda permite cargar los archivos directamente a la memoria de la sesión actual de Colab.
"""
"""
# El siguiente código sólo se ejecuta si nos encontramos en ambiente Google Colab
if 'google.colab' in str(get_ipython()):
  # Log de eventos en formato XES
  !wget https://www.dropbox.com/s/lvmucrpvssst9ir/reparacion_telefonos.xes

  # Log de eventos en formato CSV
  !wget https://www.dropbox.com/s/5etcpkq6dh7l88o/reparacion_telefonos.csv
"""
"""# 1. Instalación <a class="anchor" id="installation"></a>

- Mas detalles sobre la instalación de la librería la pueden encontrar en https://pm4py.fit.fraunhofer.de/install. Lo que se muestra aquí es un resumen.

## 1.1. Anaconda <a class="anchor" id="anaconda"></a>

- Para instalar totalmente desde cero, se puede descargar anaconda desde el siguiente link: https://www.anaconda.com/products/individual
- Con esto quedará instalar jupyter notebook y python.
"""

#!python -V

"""## 1.2. GraphViz <a class="anchor" id="graphviz"></a>

- Es necesario instalar GraphViz para visualizar los modelos que se obtendrán. En el siguiente link pueden encontrar los archivos de instalación según el sistema operativo: https://graphviz.org/download/
- Para los usuarios de Windows, en el siguiente link están las instrucciones a seguir para que quede bien instalado (inclusión al Path): https://stackoverflow.com/questions/44272416/how-to-add-a-folder-to-path-environment-variable-in-windows-10-with-screensho

## 1.3. PM4Py <a class="anchor" id="pm4py"></a>
"""

#!pip install pm4py

"""# 2. Datos <a class="anchor" id="datos"></a>

## 2.1. Importar .xes <a class="anchor" id="xes"></a>

En ambientes fuera de Google Colab, podría ser necesario instalar las siguientes dependencias, y luego reiniciar el ambiente.
"""
"""
if 'google.colab' not in str(get_ipython()):
    !pip install jupyterlab_widgets
    !pip install ipywidgets
    !jupyter nbextension enable --py widgetsnbextension

if 'google.colab' not in str(get_ipython()):
    from ipywidgets import FloatProgress
"""
"""- Creamos un objeto ```eventlog```:"""

import pm4py
eventlog_from_xes = pm4py.read_xes('reparacion_telefonos.xes')

"""- Con el siguiente comando se puede ver ***una traza*** del log:"""

print(eventlog_from_xes[0])

"""- Con el siguiente comando se puede ver ***un evento de la traza*** anterior:"""

print(eventlog_from_xes[0][0])

"""## 2.2. Importar .csv <a class="anchor" id="csv"></a>

- Instalamos la librería ```pandas```:
"""

#!pip install pandas

"""- Luego cargamos el .csv usando ```pandas```:"""

import pandas as pd

#eliminamos la columna Inicio para usar como timestamp la columna Fin.
df_csv = pd.read_csv('reparacion_telefonos.csv', sep=';').drop(columns=["Inicio"])

df_csv

"""## 2.3. De *.csv* a *event log* <a class="anchor" id="csvtoeventlog"></a>

- Primero hacemos el match entre las columnas del .csv y los parámetros del siguiente código (```case_id```, ```activity_key``` y ```timestamp_key```):
"""

df_csv_new_titles = pm4py.format_dataframe(df_csv, \
                                           case_id='Case ID', activity_key='Actividad', timestamp_key='Fin', timest_format="%d-%m-%Y %H:%M")

"""- Ahora convertimos ```df_csv_new_titles``` a objeto ```event log```:"""

from pm4py.objects.conversion.log import converter as log_converter

eventlog_from_csv = log_converter.apply(df_csv_new_titles, variant=log_converter.Variants.TO_EVENT_LOG)

"""- Podemos revisar un evento:"""

eventlog_from_csv[0][0]

"""## 2.4. De *event log* a *dataframe* de pandas <a class="anchor" id="eventlogtodf"></a>

- Para esto ocuparemos el ```event log``` creado en base al .xes (```eventlog_from_xes```). En principio la conversión se puede hacer desde cualquier objeto ```event log```.
"""

import pandas as pd
from pm4py.objects.conversion.log import converter as log_converter

dataframe_from_eventlog = log_converter.apply(eventlog_from_xes, variant=log_converter.Variants.TO_DATA_FRAME)

dataframe_from_eventlog

"""# 3. Exploración de datos <a class="anchor" id="exploracion"></a>

## 3.1. Número de casos <a class="anchor" id="ncasos"></a>
"""

len(eventlog_from_xes)

len(eventlog_from_csv)

"""## 3.2. Frecuencia de actividades <a class="anchor" id="freqactividades"></a>

- Usando pandas:
"""

dataframe_from_eventlog["Actividad"].value_counts()

"""- Usando PM4Py:"""

from pm4py.algo.filtering.pandas.attributes import attributes_filter

activities = attributes_filter.get_attribute_values(dataframe_from_eventlog, attribute_key="concept:name") #attibute_key corresponde en este caso al nombre de la columna de las actividades

activities

"""## 3.3. Frecuencia de ejecutores <a class="anchor" id="freqejecutores"></a>

- Usando pandas:
"""

dataframe_from_eventlog["Ejecutor"].value_counts()

"""- Usando PM4Py:"""

from pm4py.algo.filtering.pandas.attributes import attributes_filter

resources = attributes_filter.get_attribute_values(dataframe_from_eventlog, attribute_key="Ejecutor") #attibute_key corresponde en este caso al nombre de la columna de ejecutores

resources

"""## 3.4. Throughput time <a class="anchor" id="time"></a>

- Se obtiene una lista con la duración de todos los casos:
"""

from pm4py.statistics.traces.generic.log import case_statistics

all_case_durations = case_statistics.get_all_case_durations(eventlog_from_xes, parameters={
                                                           case_statistics.Parameters.TIMESTAMP_KEY: "time:timestamp"})

all_case_durations

"""- Ahora se puede manipular la lista con ```numpy``` para obtener algunos estadísticos descriptivos:"""

import numpy as np

np.mean(all_case_durations), np.median(all_case_durations), np.std(all_case_durations)

"""## 3.5. Distribución de case duration <a class="anchor" id="distcaseduration"></a>

- Con este gráfico se puede saber si hay casos más largos o más cortos (como dice el título, su distribución):
"""

from pm4py.util import constants
from pm4py.statistics.traces.generic.log import case_statistics

x, y = case_statistics.get_kde_caseduration(eventlog_from_xes, parameters={constants.PARAMETER_CONSTANT_TIMESTAMP_KEY: "time:timestamp"})

#############

from pm4py.visualization.graphs import visualizer as graphs_visualizer

gviz = graphs_visualizer.apply_plot(x, y, variant=graphs_visualizer.Variants.CASES)
graphs_visualizer.view(gviz)

"""## 3.6. Distribución de eventos en el tiempo <a class="anchor" id="disteventosentiempo"></a>

- Con este gráfico se puede saber el intervalo de tiempo en que hay más eventos registrados:
"""

from pm4py.algo.filtering.log.attributes import attributes_filter

x, y = attributes_filter.get_kde_date_attribute(eventlog_from_xes, attribute="time:timestamp")

############

from pm4py.visualization.graphs import visualizer as graphs_visualizer

gviz = graphs_visualizer.apply_plot(x, y, variant=graphs_visualizer.Variants.DATES)
graphs_visualizer.view(gviz)

"""## 3.7. Variantes <a class="anchor" id="variantes"></a>

- Podemos obtener el listado de variantes:
"""

from pm4py.algo.filtering.log.variants import variants_filter

variants = variants_filter.get_variants(eventlog_from_xes)

variants

"""- Y determinar el n° de variantes que existen en el event log:"""

len(variants)

"""- Podemos explorar el diccionario y seleccionar una variante en particular:"""

list(variants.keys())[0]

"""- También es posible obtener el n° de casos correspondientes a cada variante:"""

from pm4py.statistics.traces.generic.log import case_statistics

variants_count = case_statistics.get_variant_statistics(eventlog_from_xes)
variants_count = sorted(variants_count, key=lambda x: x['count'], reverse=True)

variants_count

"""# 4. Descubrimiento de proceso <a class="anchor" id="discovery"></a>

## 4.1. Algoritmo alfa <a class="anchor" id="alfa"></a>

- Aplicamos este algoritmo usando el ```eventlog_from_xes```, obteniendo la petri net, marking inicial y final:
"""

petri_net, initial_marking, final_marking = pm4py.discover_petri_net_alpha(eventlog_from_xes)

"""- Podemos visualizar la red obtenida:"""

pm4py.view_petri_net(petri_net, initial_marking, final_marking, format='png')

"""- Si quisiéramos guardar la imagen solo hay que indicar el ```file_path```:"""

pm4py.save_vis_petri_net(petri_net, initial_marking, final_marking, file_path="petrinet_alpha_eventlog_from_xes.png")

"""- Repetimos lo mismo pero esta vez usando el ```eventlog_from_csv```:"""

petri_net, initial_marking, final_marking = pm4py.discover_petri_net_alpha(eventlog_from_csv)
pm4py.view_petri_net(petri_net, initial_marking, final_marking, format='png')

"""## 4.2. Directly follows graph <a class="anchor" id="dfg"></a>

- Podemos obtener un DFG (directly follows graph) sin más información que el control flow:
"""

dfg, start_activities, end_activities = pm4py.discover_directly_follows_graph(log=eventlog_from_xes)

"""- Se puede obtener un DFG también a partir de ```eventlog_from_csv``` cambiando el parámetro ```log``` en la línea de código anterior.

- Con el siguiente código podemos visualizar el DFG obtenido, donde se muestra la frecuencia de ocurrencia de cada arco:
"""

pm4py.view_dfg(dfg, start_activities, end_activities, format='png')

"""- y con el siguiente podemos guardarlo en un archivo:"""

pm4py.save_vis_dfg(dfg, start_activities, end_activities, file_path="dfg_eventlog_from_xes.png")

"""- También podemos decorarlo con información sobre la frecuencia, estableciendo el parámetro ```log``` con el event log:"""

pm4py.view_dfg(dfg, start_activities, end_activities, format='png', log=eventlog_from_xes)

#para guardarlo con la vista de frecuencia
pm4py.save_vis_dfg(dfg, start_activities, end_activities, file_path="dfg_eventlog_from_xes.png", log=eventlog_from_xes)

"""- Y también podemos obtenerlo con información sobre el performance (tiempos de espera y de ejecución):"""

from pm4py.algo.discovery.dfg import algorithm as dfg_discovery
from pm4py.visualization.dfg import visualizer as dfg_visualization

dfg = dfg_discovery.apply(eventlog_from_xes, variant=dfg_discovery.Variants.PERFORMANCE) #para que muestre frecuencia como en los de arriba, hay que poner variant=dfg_visualization.Variants.FREQUENCY
gviz = dfg_visualization.apply(dfg, log=eventlog_from_xes, variant=dfg_visualization.Variants.PERFORMANCE) #para que muestre frecuencia como en los de arriba, hay que poner variant=dfg_visualization.Variants.FREQUENCY
dfg_visualization.view(gviz)

#para guardarlo como imagen
pm4py.save_vis_dfg(dfg, start_activities, end_activities, file_path="dfg_performance_eventlog_from_xes.png", log=eventlog_from_xes)
dfg_visualization.save(gviz, "dfg.svg")

"""# 5. Filtros <a class="anchor" id="filtros"></a>

- Primero hay que cargar la siguiente línea de comandos:
"""

from pm4py.algo.filtering.log.attributes import attributes_filter

"""## 5.1. Filtrar por start activity <a class="anchor" id="filtro1"></a>

- Con este filtro nos quedamos sólo con los casos que **empiezan** con actividades específicas.

- Primero tenemos que ver con cuáles actividades los casos comienzan (ocuparemos el ```eventlog_from_csv``` que tiene casos incompletos):
"""

from pm4py.algo.filtering.log.start_activities import start_activities_filter

start_activities = start_activities_filter.get_start_activities(eventlog_from_csv)

start_activities

"""- Luego hacemos el filtro por la actividad que queramos. En este caso, filtraremos quedándonos con los casos que comienzan con la actividad "Registrar":"""

filtered_log = start_activities_filter.apply(eventlog_from_csv, ["Registrar"])

len(filtered_log)

"""## 5.2. Filtrar por end activity <a class="anchor" id="filtro2"></a>

- Con este filtro nos quedamos sólo con los casos que **terminan** con actividades específicas.

- Ahora vemos con cuáles actividades los casos terminan (ocuparemos el ```filtered_log``` filtrado por actividades que comienzan con actividad "Registrar"):
"""

from pm4py.algo.filtering.log.end_activities import end_activities_filter

end_activities = end_activities_filter.get_end_activities(filtered_log)

end_activities

"""- Luego hacemos el filtro por la actividad que queramos. En este caso, filtraremos quedándonos con los casos que terminan con la actividad "Archivar reparacion":"""

filtered_log = end_activities_filter.apply(eventlog_from_csv, ["Archivar reparacion"])

len(filtered_log)

"""- Ahora que tenemos sólo casos completos, podemos aplicar el algoritmo alfa:"""

petri_net, initial_marking, final_marking = pm4py.discover_petri_net_alpha(filtered_log)
pm4py.view_petri_net(petri_net, initial_marking, final_marking, format='png')

"""## 5.3. Filtrar trazas que contienen una actividad <a class="anchor" id="filtro3"></a>

- Quedan sólo las **trazas que contienen** una actividad específica. En este caso, las trazas que contienen la actividad 'Volver a reparar':
"""

filtered_eventlog = attributes_filter.apply(eventlog_from_xes, ['Volver a reparar'],
                                          parameters={attributes_filter.Parameters.ATTRIBUTE_KEY: "concept:name", attributes_filter.Parameters.POSITIVE: True})

len(filtered_eventlog)

"""- Descubrimos nuevamente el DFG usando el event log filtrado:"""

dfg, start_activities, end_activities = pm4py.discover_directly_follows_graph(log=filtered_eventlog)
pm4py.view_dfg(dfg, start_activities, end_activities, format='png')

"""## 5.4. Filtrar trazas que no contienen una actividad <a class="anchor" id="filtro4"></a>

- Quedan sólo las trazas que **NO contienen** una actividad específica. En este caso, las trazas que no contienen la actividad 'Volver a reparar':
"""

filtered_eventlog = attributes_filter.apply(eventlog_from_xes, ['Volver a reparar'],\
                                          parameters={attributes_filter.Parameters.CASE_ID_KEY: "case:concept:name", attributes_filter.Parameters.ATTRIBUTE_KEY: "concept:name", attributes_filter.Parameters.POSITIVE: False})

len(filtered_eventlog)

dfg, start_activities, end_activities = pm4py.discover_directly_follows_graph(log=filtered_eventlog)
pm4py.view_dfg(dfg, start_activities, end_activities, format='png')

"""## 5.5. Eliminar todos los eventos de una actividad <a class="anchor" id="filtro5"></a>

- Con este filtro se **eliminan todos los eventos** de una determinada actividad. En este caso, se eliminará la actividad 'Informar a cliente':
"""

filtered_eventlog = attributes_filter.apply_events(eventlog_from_xes, ['Informar a cliente'],
                                          parameters={attributes_filter.Parameters.CASE_ID_KEY: "case:concept:name", attributes_filter.Parameters.ATTRIBUTE_KEY: "concept:name", attributes_filter.Parameters.POSITIVE: False})

len(filtered_eventlog)

dfg, start_activities, end_activities = pm4py.discover_directly_follows_graph(log=filtered_eventlog)
pm4py.view_dfg(dfg, start_activities, end_activities, format='png')

"""## 5.6. Filtrar por duración de caso <a class="anchor" id="filtro6"></a>

- Es posible filtrar para obtener los casos que duran entre cierta cantidad de tiempo. En este caso, nos quedaremos con los casos que duran entre 3600 segundos y 5400 segundos:
"""

from pm4py.algo.filtering.log.cases import case_filter
filtered_eventlog = case_filter.filter_case_performance(eventlog_from_xes, 3600, 5400) #en segundos (1 hora y 1 hr30min)

len(filtered_eventlog)

dfg, start_activities, end_activities = pm4py.discover_directly_follows_graph(log=filtered_eventlog)
pm4py.view_dfg(dfg, start_activities, end_activities, format='png')

"""## 5.7. Filtrar trazas contenidas en un período de tiempo <a class="anchor" id="filtro7"></a>

- Con este filtro nos quedamos sólo con las trazas que se ejecutaron en un intervalo de tiempo determinado. En este caso, nos quedaremos con aquellos entre "2011-01-01 00:00:00" y "2011-01-05 23:59:59":
"""

from pm4py.algo.filtering.log.timestamp import timestamp_filter
filtered_eventlog = timestamp_filter.filter_traces_contained(eventlog_from_xes, "2011-01-01 00:00:00", "2011-01-05 23:59:59")

len(filtered_eventlog)

dfg, start_activities, end_activities = pm4py.discover_directly_follows_graph(log=filtered_eventlog)
pm4py.view_dfg(dfg, start_activities, end_activities, format='png')

"""## 5.8. Filtrar casos por variante <a class="anchor" id="filtro8"></a>

- Podemos crear una lista con las variantes que queremos conservar:
"""

from pm4py.algo.filtering.log.variants import variants_filter

variants = ['Registrar,Analizar defecto,Informar a cliente,Reparacion (compleja),Probar reparacion,Archivar reparacion',
           'Registrar,Analizar defecto,Reparacion (compleja),Probar reparacion,Informar a cliente,Archivar reparacion']

filtered_eventlog = variants_filter.apply(eventlog_from_xes, variants)

len(filtered_eventlog)

dfg, start_activities, end_activities = pm4py.discover_directly_follows_graph(log=filtered_eventlog)
pm4py.view_dfg(dfg, start_activities, end_activities, format='png')